<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>強化・ブロック崩し</title>
    <style>
        body { background: #111; color: #fff; text-align: center; font-family: sans-serif; overflow: hidden; touch-action: none; margin: 0; }
        canvas { background: #000; display: block; margin: 5px auto; border: 2px solid #555; max-width: 95vw; max-height: 70vh; }
        .info-panel { display: flex; justify-content: space-around; font-size: 18px; margin: 5px; color: #0f0; }
        #restartBtn { display: none; padding: 15px 30px; font-size: 20px; background: #28a745; color: white; border: none; border-radius: 5px; margin-top: 10px; cursor: pointer; }
    </style>
</head>
<body>
    <h2 style="margin: 5px; color: #ddd;">BLOCK BREAKER EVOLVED</h2>
    <div class="info-panel">
        <div>SCORE: <span id="score">0</span></div>
        <div>TIME: <span id="timer">180</span>s</div>
    </div>
    <canvas id="gameCanvas" width="440" height="520"></canvas>
    <button id="restartBtn" onclick="resetGame()">RETRY</button>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const scoreDisplay = document.getElementById("score");
        const timerDisplay = document.getElementById("timer");
        const restartBtn = document.getElementById("restartBtn");

        let score = 0;
        let timeLeft = 180;
        let gameTimer;
        let isGameOver = false;

        const ballRadius = 6;
        let balls = [];
        let baseSpeed = 3.5;

        const paddleHeight = 12;
        let defaultPaddleWidth = 60;
        let paddleWidth = defaultPaddleWidth;
        let paddleX;
        let paddleEffectTimer = null;

        const brickRowCount = 7;
        const brickColumnCount = 8;
        const brickWidth = 46;
        const brickHeight = 16;
        const brickPadding = 6;
        const brickOffsetTop = 50;
        const brickOffsetLeft = 15;

        let bricks = [];
        let items = [];

        function initGame() {
            score = 0;
            timeLeft = 180;
            isGameOver = false;
            paddleWidth = defaultPaddleWidth;
            scoreDisplay.innerHTML = score;
            timerDisplay.innerHTML = timeLeft;
            restartBtn.style.display = "none";
            if(paddleEffectTimer) clearTimeout(paddleEffectTimer);

            balls = [{ x: canvas.width/2, y: canvas.height-40, dx: baseSpeed, dy: -baseSpeed, active: true }];
            paddleX = (canvas.width - paddleWidth) / 2;
            items = [];

            bricks = [];
            for(let c=0; c<brickColumnCount; c++) {
                bricks[c] = [];
                for(let r=0; r<brickRowCount; r++) {
                    // 1行目と3行目の一部を耐久ブロック（HP2）にする
                    let hp = (r === 0 || r === 2) && (c % 2 === 0) ? 2 : 1;
                    bricks[c][r] = { x: 0, y: 0, status: hp, points: (7 - r) * 10 };
                }
            }

            if(gameTimer) clearInterval(gameTimer);
            gameTimer = setInterval(() => {
                if(!isGameOver) {
                    timeLeft--;
                    timerDisplay.innerHTML = timeLeft;
                    if(timeLeft <= 0) endGame("TIME UP!");
                }
            }, 1000);
        }

        function movePaddle(clientX) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            let relativeX = (clientX - rect.left) * scaleX;
            paddleX = relativeX - paddleWidth / 2;
            if(paddleX < 0) paddleX = 0;
            if(paddleX + paddleWidth > canvas.width) paddleX = canvas.width - paddleWidth;
        }

        document.addEventListener("touchmove", (e) => { e.preventDefault(); movePaddle(e.touches[0].clientX); }, {passive: false});
        document.addEventListener("mousemove", (e) => { movePaddle(e.clientX); });

        function collisionDetection() {
            for(let c=0; c<brickColumnCount; c++) {
                for(let r=0; r<brickRowCount; r++) {
                    let b = bricks[c][r];
                    if(b.status > 0) {
                        balls.forEach(ball => {
                            if(!ball.active) return;
                            if(ball.x > b.x && ball.x < b.x + brickWidth && ball.y > b.y && ball.y < b.y + brickHeight) {
                                ball.dy = -ball.dy;
                                b.status--; 
                                if(b.status === 0) {
                                    score += b.points;
                                    scoreDisplay.innerHTML = score;
                                    if(Math.random() < 0.12) { // 出現率12%に微増
                                        const type = Math.random() < 0.5 ? 'wide' : 'multi';
                                        items.push({ x: b.x + brickWidth/2, y: b.y, type: type });
                                    }
                                }
                                if(bricks.flat().every(bk => bk.status === 0)) endGame("ALL CLEAR!");
                            }
                        });
                    }
                }
            }
        }

        function endGame(msg) {
            isGameOver = true;
            clearInterval(gameTimer);
            ctx.fillStyle = "rgba(0,0,0,0.85)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#fff";
            ctx.textAlign = "center";
            ctx.font = "bold 24px sans-serif";
            ctx.fillText(msg, canvas.width/2, canvas.height/2 - 20);
            ctx.font = "bold 32px sans-serif";
            ctx.fillText("SCORE: " + score, canvas.width/2, canvas.height/2 + 30);
            restartBtn.style.display = "inline-block";
        }

        function resetGame() { initGame(); draw(); }

        function draw() {
            if(isGameOver) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ブロック描画
            for(let c=0; c<brickColumnCount; c++) {
                for(let r=0; r<brickRowCount; r++) {
                    let b = bricks[c][r];
                    if(b.status > 0) {
                        let bx = (c * (brickWidth + brickPadding)) + brickOffsetLeft;
                        let by = (r * (brickHeight + brickPadding)) + brickOffsetTop;
                        b.x = bx; b.y = by;
                        if(b.status === 2) {
                            ctx.fillStyle = "#888"; // 耐久ブロックはグレー
                        } else {
                            ctx.fillStyle = `hsl(${r * 40}, 75%, 50%)`;
                        }
                        ctx.fillRect(bx, by, brickWidth, brickHeight);
                        // 耐久ブロックに枠線を付けて硬そうに見せる
                        if(b.status === 2) {
                            ctx.strokeStyle = "#fff";
                            ctx.strokeRect(bx, by, brickWidth, brickHeight);
                        }
                    }
                }
            }

            // アイテム描画と取得
            items.forEach((item, index) => {
                item.y += 2.5;
                ctx.fillStyle = item.type === 'wide' ? "#0af" : "#f1c40f";
                ctx.beginPath();
                ctx.arc(item.x, item.y, 10, 0, Math.PI*2);
                ctx.fill();
                ctx.fillStyle = "#000";
                ctx.font = "bold 12px sans-serif";
                ctx.fillText(item.type === 'wide' ? "W" : "M", item.x, item.y + 4);

                if(item.y + 10 > canvas.height - paddleHeight && item.x > paddleX && item.x < paddleX + paddleWidth) {
                    if(item.type === 'wide') {
                        paddleWidth += 25; // 取るたびに25px伸びる（重ね掛け）
                        if(paddleEffectTimer) clearTimeout(paddleEffectTimer);
                        paddleEffectTimer = setTimeout(() => { paddleWidth = defaultPaddleWidth; }, 10000);
                    } else if(item.type === 'multi') {
                        // 現在の生きてる全てのボールを分裂させる（重ね掛け）
                        let currentBalls = balls.filter(b => b.active);
                        currentBalls.forEach(b => {
                            balls.push({ x: b.x, y: b.y, dx: -b.dx, dy: b.dy, active: true });
                        });
                    }
                    items.splice(index, 1);
                }
                if(item.y > canvas.height) items.splice(index, 1);
            });

            // パドル
            ctx.fillStyle = "#0af";
            ctx.fillRect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);

            // ボール描画と移動
            balls.forEach(ball => {
                if(!ball.active) return;
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ballRadius, 0, Math.PI*2);
                ctx.fillStyle = "#fff";
                ctx.fill();
                ctx.closePath();

                if(ball.x + ball.dx > canvas.width - ballRadius || ball.x + ball.dx < ballRadius) ball.dx = -ball.dx;
                if(ball.y + ball.dy < ballRadius) ball.dy = -ball.dy;
                else if(ball.y + ball.dy > canvas.height - ballRadius) {
                    if(ball.x > paddleX && ball.x < paddleX + paddleWidth) {
                        ball.dy = -ball.dy;
                        // 当たる位置によって反射角度を少し変える
                        let deltaX = ball.x - (paddleX + paddleWidth/2);
                        ball.dx = deltaX * 0.15;
                    } else {
                        ball.active = false;
                        if(balls.filter(b => b.active).length === 0) endGame("GAME OVER");
                    }
                }
                ball.x += ball.dx; ball.y += ball.dy;
            });

            collisionDetection();
            requestAnimationFrame(draw);
        }

        initGame();
        draw();
    </script>
</body>
</html>