<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>アイテム進化版・ブロック崩し</title>
    <style>
        body { background: #222; color: #fff; text-align: center; font-family: sans-serif; overflow: hidden; touch-action: none; margin: 0; }
        canvas { background: #000; display: block; margin: 5px auto; border: 2px solid #fff; max-width: 95vw; max-height: 65vh; }
        .info-panel { display: flex; justify-content: space-around; font-size: 18px; margin: 5px; }
        #restartBtn { display: none; padding: 15px 30px; font-size: 20px; background: #28a745; color: white; border: none; border-radius: 5px; margin-top: 10px; }
    </style>
</head>
<body>
    <h2 style="margin: 5px;">BLOCK BREAKER+</h2>
    <div class="info-panel">
        <div>スコア: <span id="score">0</span></div>
        <div>残り時間: <span id="timer">180</span>s</div>
    </div>
    <canvas id="gameCanvas" width="400" height="500"></canvas>
    <button id="restartBtn" onclick="resetGame()">もう一度挑戦する</button>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const scoreDisplay = document.getElementById("score");
        const timerDisplay = document.getElementById("timer");
        const restartBtn = document.getElementById("restartBtn");

        let score = 0;
        let timeLeft = 180;
        let gameTimer;
        let isGameOver = false;

        const ballRadius = 6;
        let balls = []; // 複数の玉を管理
        let baseSpeed = 3;

        const paddleHeight = 12;
        let defaultPaddleWidth = 60;
        let paddleWidth = defaultPaddleWidth;
        let paddleX;
        let paddleTimer = null;

        const brickRowCount = 6;
        const brickColumnCount = 7;
        const brickWidth = 45;
        const brickHeight = 15;
        const brickPadding = 7;
        const brickOffsetTop = 40;
        const brickOffsetLeft = 20;

        let bricks = [];
        let items = []; // 落ちてくるアイテムを管理

        function initGame() {
            score = 0;
            timeLeft = 180;
            isGameOver = false;
            paddleWidth = defaultPaddleWidth;
            scoreDisplay.innerHTML = score;
            timerDisplay.innerHTML = timeLeft;
            restartBtn.style.display = "none";
            if(paddleTimer) clearTimeout(paddleTimer);

            // 初期の玉を1つ作成
            balls = [{ x: canvas.width/2, y: canvas.height-30, dx: baseSpeed, dy: -baseSpeed, active: true }];
            paddleX = (canvas.width - paddleWidth) / 2;
            items = [];

            bricks = [];
            for(let c=0; c<brickColumnCount; c++) {
                bricks[c] = [];
                for(let r=0; r<brickRowCount; r++) {
                    bricks[c][r] = { x: 0, y: 0, status: 1, points: (6 - r) };
                }
            }

            if(gameTimer) clearInterval(gameTimer);
            gameTimer = setInterval(() => {
                if(!isGameOver) {
                    timeLeft--;
                    timerDisplay.innerHTML = timeLeft;
                    if(timeLeft <= 0) endGame("タイムアップ！");
                }
            }, 1000);
        }

        function movePaddle(clientX) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            let relativeX = (clientX - rect.left) * scaleX;
            paddleX = relativeX - paddleWidth / 2;
            if(paddleX < 0) paddleX = 0;
            if(paddleX + paddleWidth > canvas.width) paddleX = canvas.width - paddleWidth;
        }

        document.addEventListener("touchmove", (e) => { e.preventDefault(); movePaddle(e.touches[0].clientX); }, {passive: false});
        document.addEventListener("mousemove", (e) => { movePaddle(e.clientX); });

        function collisionDetection() {
            for(let c=0; c<brickColumnCount; c++) {
                for(let r=0; r<brickRowCount; r++) {
                    let b = bricks[c][r];
                    if(b.status == 1) {
                        balls.forEach(ball => {
                            if(!ball.active) return;
                            if(ball.x > b.x && ball.x < b.x + brickWidth && ball.y > b.y && ball.y < b.y + brickHeight) {
                                ball.dy = -ball.dy;
                                b.status = 0;
                                score += b.points;
                                scoreDisplay.innerHTML = score;

                                // 10%の確率でアイテム出現
                                if(Math.random() < 0.10) {
                                    const type = Math.random() < 0.5 ? 'wide' : 'multi';
                                    items.push({ x: b.x + brickWidth/2, y: b.y, type: type });
                                }

                                if(bricks.flat().every(bk => bk.status === 0)) endGame("パーフェクトクリア！");
                            }
                        });
                    }
                }
            }
        }

        function endGame(msg) {
            isGameOver = true;
            clearInterval(gameTimer);
            ctx.fillStyle = "rgba(0,0,0,0.8)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            ctx.font = "22px sans-serif";
            ctx.fillText(msg, canvas.width/2, canvas.height/2 - 20);
            ctx.font = "28px sans-serif";
            ctx.fillText("最終得点: " + score, canvas.width/2, canvas.height/2 + 30);
            restartBtn.style.display = "inline-block";
        }

        function resetGame() { initGame(); draw(); }

        function draw() {
            if(isGameOver) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ブロック
            for(let c=0; c<brickColumnCount; c++) {
                for(let r=0; r<brickRowCount; r++) {
                    if(bricks[c][r].status == 1) {
                        let bx = (c * (brickWidth + brickPadding)) + brickOffsetLeft;
                        let by = (r * (brickHeight + brickPadding)) + brickOffsetTop;
                        bricks[c][r].x = bx; bricks[c][r].y = by;
                        ctx.fillStyle = `hsl(${r * 45}, 70%, 50%)`;
                        ctx.fillRect(bx, by, brickWidth, brickHeight);
                    }
                }
            }

            // アイテムの移動と描画
            items.forEach((item, index) => {
                item.y += 2;
                ctx.fillStyle = item.type === 'wide' ? "#00f" : "#ff0";
                ctx.fillRect(item.x - 10, item.y, 20, 20);
                ctx.fillStyle = "#fff";
                ctx.font = "12px sans-serif";
                ctx.fillText(item.type === 'wide' ? "W" : "M", item.x, item.y + 15);

                // アイテム取得判定
                if(item.y + 20 > canvas.height - paddleHeight && item.x > paddleX && item.x < paddleX + paddleWidth) {
                    if(item.type === 'wide') {
                        paddleWidth = defaultPaddleWidth * 1.5;
                        if(paddleTimer) clearTimeout(paddleTimer);
                        paddleTimer = setTimeout(() => { paddleWidth = defaultPaddleWidth; }, 10000);
                    } else if(item.type === 'multi' && balls.filter(b => b.active).length === 1) {
                        // 玉を3つにする（現在の玉の向きを変えて3方向に飛ばす）
                        let mainBall = balls.find(b => b.active);
                        balls.push({ x: mainBall.x, y: mainBall.y, dx: baseSpeed, dy: -baseSpeed, active: true });
                        balls.push({ x: mainBall.x, y: mainBall.y, dx: -baseSpeed, dy: -baseSpeed, active: true });
                    }
                    items.splice(index, 1);
                }
                if(item.y > canvas.height) items.splice(index, 1);
            });

            // パドル
            ctx.fillStyle = "#0095DD";
            ctx.fillRect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);

            // 玉の移動と描画
            balls.forEach((ball, index) => {
                if(!ball.active) return;
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ballRadius, 0, Math.PI*2);
                ctx.fillStyle = "#fff";
                ctx.fill();
                ctx.closePath();

                if(ball.x + ball.dx > canvas.width - ballRadius || ball.x + ball.dx < ballRadius) ball.dx = -ball.dx;
                if(ball.y + ball.dy < ballRadius) ball.dy = -ball.dy;
                else if(ball.y + ball.dy > canvas.height - ballRadius) {
                    if(ball.x > paddleX && ball.x < paddleX + paddleWidth) {
                        ball.dy = -ball.dy;
                    } else {
                        ball.active = false; // 玉を無効化
                        if(balls.filter(b => b.active).length === 0) {
                            endGame("ゲームオーバー");
                        }
                    }
                }
                ball.x += ball.dx; ball.y += ball.dy;
            });

            collisionDetection();
            requestAnimationFrame(draw);
        }

        initGame();
        draw();
    </script>
</body>
</html>