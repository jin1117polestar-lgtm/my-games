<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BLOCK BREAKER - STABLE VERSION</title>
    <style>
        html, body { background: #000; color: #fff; text-align: center; font-family: sans-serif; overflow: hidden; touch-action: none; margin: 0; width: 100%; height: 100%; }
        #game-container { display: flex; flex-direction: column; height: 100vh; }
        .ui-top { height: 40px; display: flex; justify-content: space-around; align-items: center; background: #111; color: #0f0; font-size: 14px; flex-shrink: 0; }
        #screen-area { position: relative; flex-grow: 1; width: 100%; background: #000; overflow: hidden;}
        canvas { display: block; margin: 0 auto; width: 100%; height: 100%; object-fit: contain; border: 1px solid #333; }
        #touch-area { height: 25vh; width: 100%; background: #0a0a0a; display: flex; justify-content: center; align-items: center; border-top: 2px solid #333; flex-shrink: 0; }
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; }
        button { padding: 15px 40px; font-size: 18px; background: #28a745; color: white; border: none; border-radius: 50px; cursor: pointer; margin: 8px; font-weight: bold; min-width: 220px; }
        .new-record { color: #f0f; font-weight: bold; animation: flash 0.5s infinite; font-size: 20px; margin: 5px 0; }
        @keyframes flash { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
        .boss-hp-bar { width: 80%; height: 12px; background: #333; border: 2px solid #fff; position: absolute; top: 10px; left: 10%; z-index: 10; display: none; overflow: hidden; border-radius: 6px; }
        #boss-hp-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #f00, #ff0); transition: width 0.1s; }
    </style>
</head>
<body>

<div id="game-container">
    <div class="ui-top">
        <div>STAGE: <span id="stage-num">1</span></div>
        <div>SCORE: <span id="score">0</span></div>
        <div>TIME: <span id="timer">300</span></div>
    </div>
    
    <div id="screen-area">
        <div id="boss-ui" class="boss-hp-bar"><div id="boss-hp-fill"></div></div>
        <canvas id="gameCanvas" width="400" height="500"></canvas>

        <div id="start-screen" class="overlay">
            <h1 style="color:#0f0;">BLOCK BREAKER</h1>
            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px; margin-bottom: 10px;">
                BEST SCORE: <span id="best-score">0</span><br>
                BEST TIME: <span id="best-time">--:--</span>
            </div>
            <button onclick="startGame()">GAME START</button><br>
            <button style="background:#444; font-size:12px; min-width:120px;" onclick="resetRecords()">RESET RECORDS</button>
        </div>

        <div id="intermission-screen" class="overlay" style="display:none">
            <h2 style="color:#0f0;">STAGE CLEAR!</h2>
            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px; margin-bottom: 15px;">
                CURRENT SCORE: <span id="inter-score">0</span><br>
                TIME LEFT: <span id="inter-time">0</span>
            </div>
            <div id="inter-record-notice" class="new-record" style="display:none">NEW HIGH SCORE!</div>
            <button onclick="continueGame()">NEXT STAGE</button><br>
            <button onclick="location.reload()" style="background:#555;">BACK TO TITLE</button>
        </div>

        <div id="result-screen" class="overlay" style="display:none">
            <h2 id="result-msg">GAME OVER</h2>
            <div id="final-score-display" style="font-size:36px; color:#ff0; font-weight:bold;">0</div>
            <div id="record-notice" class="new-record" style="display:none">NEW RECORD!</div>
            <div id="final-stats" style="color:#aaa; margin: 15px 0;"></div>
            <button onclick="location.reload()">BACK TO TITLE</button>
        </div>
    </div>

    <div id="touch-area"><div style="color:#444; font-size:12px;">▲ SLIDE TO CONTROL ▲</div></div>
</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

const INITIAL_PADDLE_WIDTH = 60;
const BASE_SPEED = 280; // 秒間移動ピクセル数に調整
const MAX_SPEED_CAP = 550; // 最大速度制限
const EFFECT_TIME = 10; // 秒単位に調整

let gameState = "TITLE";
let stage = 1, score = 0, timeLeft = 300, clearCalled = false;
let combo = 0, comboTimer = 0, shakeTime = 0, gameInterval;
let paddleSizeTimer = 0;
let paddleWidth = INITIAL_PADDLE_WIDTH, paddleX = 170;
let currentTargetSpeed = BASE_SPEED;
let balls = [], bricks = [], items = [], wallBricks = [], boss = null, advanceY = 0;

// 時間制御用の変数
let lastTime = 0;

function updateRecordsDisplay() {
    const s = localStorage.getItem('bestScore') || 0;
    const t = localStorage.getItem('bestTime');
    document.getElementById('best-score').innerText = s;
    document.getElementById('best-time').innerText = t ? formatTime(t) : "--:--";
}

function resetRecords() {
    const pw = prompt("パスワード：");
    if (pw === "1117") {
        localStorage.removeItem('bestScore'); localStorage.removeItem('bestTime');
        updateRecordsDisplay(); alert("Records Reset OK");
    } else if (pw === "2222") { stage = 2; startGame(2); } 
    else if (pw === "3333") { stage = 3; startGame(3); }
}

function formatTime(sec) {
    let m = Math.floor(sec / 60); let s = sec % 60;
    return `${m}:${s < 10 ? '0' : ''}${s}`;
}

function initStage(n) {
    stage = n; clearCalled = false; advanceY = 0;
    bricks = []; items = []; wallBricks = []; boss = null;
    document.getElementById("stage-num").innerText = n;
    
    currentTargetSpeed = BASE_SPEED + (n * 30);
    // ボールの初速度を設定
    balls = [{ 
        x: 200, y: 400, 
        dx: currentTargetSpeed * 0.7, 
        dy: -currentTargetSpeed * 0.7, 
        active: true 
    }];
    
    document.getElementById("boss-ui").style.display = (n === 3) ? "block" : "none";
    
    if (n === 1) createBricks(5, 7, false);
    else if (n === 2) {
        createBricks(6, 8, true);
        for(let i=0; i<4; i++) wallBricks.push({x: i*100 + 35, y: 220, w: 50, h: 15});
    } else if (n === 3) {
        createBricks(3, 8, true); 
        boss = { x: 100, y: 30, w: 200, h: 100, hp: 120, maxHp: 120 };
    }
}

function createBricks(rows, cols, hasHard) {
    for(let c=0; c<cols; c++) {
        bricks[c] = [];
        for(let r=0; r<rows; r++) {
            let prob = (stage === 3) ? 0.25 : 0.1;
            bricks[c][r] = { status: (hasHard && Math.random() < prob) ? 2 : 1, row: r };
        }
    }
}

let lastTouchX = null;
window.addEventListener("touchstart", e => { lastTouchX = e.touches[0].clientX; }, {passive: false});
window.addEventListener("touchmove", e => {
    if (gameState !== "PLAY" || lastTouchX === null) return;
    const deltaX = (e.touches[0].clientX - lastTouchX) * 1.8;
    paddleX = Math.max(0, Math.min(canvas.width - paddleWidth, paddleX + deltaX));
    lastTouchX = e.touches[0].clientX;
    if (e.cancelable) e.preventDefault();
}, {passive: false});
window.addEventListener("touchend", () => { lastTouchX = null; });

function startGame(targetStage = 1) {
    gameState = "PLAY";
    document.getElementById("start-screen").style.display = "none";
    score = 0; timeLeft = 300; paddleWidth = INITIAL_PADDLE_WIDTH; paddleSizeTimer = 0;
    initStage(targetStage);
    
    lastTime = performance.now(); // タイマーリセット
    if(gameInterval) clearInterval(gameInterval);
    gameInterval = setInterval(() => {
        if(gameState === "PLAY") {
            timeLeft--; document.getElementById("timer").innerText = timeLeft;
            if(timeLeft <= 0) endGame(false);
        }
    }, 1000);
    requestAnimationFrame(gameLoop);
}

function gameLoop(timestamp) {
    if (gameState === "RESULT") return;
    
    // 前のフレームからの経過時間（秒）を算出
    let dt = (timestamp - lastTime) / 1000;
    if (dt > 0.1) dt = 0.1; // ブラウザのタブ切り替え時の跳ね返り防止
    lastTime = timestamp;

    if (gameState === "PLAY") { 
        update(dt); 
        draw(); 
    }
    requestAnimationFrame(gameLoop);
}

// 修正ポイント：dt（デルタタイム）を引数にして移動距離を計算
function update(dt) {
    if (paddleSizeTimer > 0) {
        paddleSizeTimer -= dt;
        if (paddleSizeTimer <= 0) paddleWidth = INITIAL_PADDLE_WIDTH;
    }
    if (comboTimer > 0) comboTimer -= dt; else combo = 0;
    
    if (stage === 3) advanceY += 3.5 * dt; 
    if (advanceY > 280) endGame(false);

    balls.forEach(b => {
        if(!b.active) return;
        
        // 移動：現在の速度に経過時間を掛ける
        b.x += b.dx * dt;
        b.y += b.dy * dt;

        // 壁反射（正規化処理含む）
        const minDx = 100; 
        if (b.x < 7) { b.dx = Math.abs(b.dx); if (b.dx < minDx) b.dx = minDx; b.x = 7; } 
        else if (b.x > 393) { b.dx = -Math.abs(b.dx); if (b.dx > -minDx) b.dx = -minDx; b.x = 393; }
        if (b.y < 7) { b.dy = Math.abs(b.dy); b.y = 7; }

        // パドル反射
        if (b.y > 473 && b.y < 490 && b.x > paddleX && b.x < paddleX + paddleWidth) {
            let hit = (b.x - (paddleX + paddleWidth/2)) / (paddleWidth/2);
            let angle = hit * (Math.PI / 3);
            if(Math.abs(angle) < 0.25) angle = hit < 0 ? -0.25 : 0.25; 
            
            // 速度の大きさを一定に保つ
            b.dx = currentTargetSpeed * Math.sin(angle);
            b.dy = -currentTargetSpeed * Math.cos(angle);
            b.y = 472; combo = 0;
        }

        if (b.y > 520) { b.active = false; if (balls.filter(a => a.active).length === 0) endGame(false); }

        // ブロック判定
        bricks.forEach((col, c) => col.forEach((br, r) => {
            if (br.status > 0) {
                let bx = c*(47)+30, by = r*(20)+50+advanceY;
                if (b.x > bx && b.x < bx+42 && b.y > by && b.y < by+15) {
                    b.dy *= -1; br.status--;
                    combo++; comboTimer = 1.0;
                    score += (6 - br.row) * 10 * combo;
                    document.getElementById("score").innerText = score;
                    if (br.status === 0 && Math.random() < 0.15) spawnItem(bx+21, by);
                    
                    // 徐々に加速するが、上限を設定
                    if (currentTargetSpeed < MAX_SPEED_CAP) currentTargetSpeed += 2;
                    shakeTime = 3;
                }
            }
        }));

        wallBricks.forEach(w => {
            if (b.x > w.x-5 && b.x < w.x+w.w+5 && b.y > w.y-5 && b.y < w.y+w.h+5) {
                if (Math.abs(b.x - (w.x + w.w/2)) > Math.abs(b.y - (w.y + w.h/2))) b.dx *= -1; else b.dy *= -1;
                score += 5;
            }
        });

        if (boss) {
            let bx = boss.x, by = boss.y + advanceY/2;
            if (b.x > bx && b.x < bx + boss.w && b.y > by && b.y < by + boss.h) {
                let centerX = bx + boss.w/2;
                let centerY = by + boss.h/2;
                let distToCore = Math.sqrt((b.x-centerX)**2 + (b.y-centerY)**2);
                if (distToCore < 35) { 
                    boss.hp -= 2.5; shakeTime = 15;
                    combo++; comboTimer = 1.0;
                    score += 50 * combo;
                    // 急激な反射を抑えつつ反転
                    b.dy = Math.abs(b.dy) * 1.02; 
                } else {
                    if (Math.abs(b.x - centerX) > Math.abs(b.y - centerY)) b.dx *= -1; else b.dy *= -1;
                    boss.hp -= 0.5; score += 10;
                    shakeTime = 5; combo++; comboTimer = 0.5;
                }
                document.getElementById("score").innerText = score;
                if (boss.hp <= 0) endGame(true);
            }
        }
    });

    items.forEach((it, i) => {
        it.y += 150 * dt; // アイテムの落下速度もdtで制御
        if (it.y > 475 && it.y < 500 && it.x > paddleX && it.x < paddleX + paddleWidth) {
            if (it.type === 'L') { paddleWidth = 110; paddleSizeTimer = 10; }
            if (it.type === 'S') { paddleWidth = 35; paddleSizeTimer = 10; }
            if (it.type === 'M') { 
                const activeBalls = balls.filter(b=>b.active);
                activeBalls.forEach(b => balls.push({x:b.x, y:b.y, dx:-b.dx, dy:b.dy, active:true})); 
            }
            items.splice(i, 1);
        } else if (it.y > 505) items.splice(i, 1);
    });

    if (!boss && !clearCalled && bricks.length > 0 && bricks.flat().every(b => b.status === 0)) {
        clearCalled = true;
        if (stage < 3) showIntermission(); else endGame(true);
    }
}

function spawnItem(x, y) {
    const types = ['L', 'S', 'M'];
    items.push({ x, y, type: types[Math.floor(Math.random()*types.length)] });
}

function draw() {
    ctx.save();
    if(shakeTime > 0) { ctx.translate((Math.random()-0.5)*shakeTime, (Math.random()-0.5)*shakeTime); shakeTime--; }
    ctx.clearRect(-20, -20, 440, 540);

    let bw = 42, bh = 15, pad = 5, offT = 50 + advanceY, offL = 30;
    bricks.forEach((col, c) => col.forEach((b, r) => {
        if(b.status > 0) {
            let x = c*(bw+pad)+offL, y = r*(bh+pad)+offT;
            ctx.fillStyle = b.status === 2 ? "#AAA" : `hsl(${r*40}, 70%, 50%)`;
            ctx.fillRect(x, y, bw, bh);
            if(b.status === 2) { ctx.strokeStyle = "#FFF"; ctx.strokeRect(x,y,bw,bh); }
        }
    }));

    wallBricks.forEach(w => {
        ctx.fillStyle = "rgba(150, 255, 255, 0.5)"; ctx.fillRect(w.x, w.y, w.w, w.h);
        ctx.strokeStyle = "#fff"; ctx.strokeRect(w.x, w.y, w.w, w.h);
    });

    if (boss) {
        let bx = boss.x, by = boss.y + advanceY/2;
        ctx.fillStyle = "rgba(80, 0, 120, 0.6)"; ctx.fillRect(bx, by, boss.w, boss.h);
        ctx.strokeStyle = "#f0f"; ctx.lineWidth = 2; ctx.strokeRect(bx, by, boss.w, boss.h);
        let pulse = Math.sin(Date.now()/100)*5;
        ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.arc(bx+boss.w/2, by+boss.h/2, 25+pulse, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "#f00"; ctx.beginPath(); ctx.arc(bx+boss.w/2, by+boss.h/2, 12+pulse, 0, Math.PI*2); ctx.fill();
        document.getElementById("boss-hp-fill").style.width = (boss.hp/boss.maxHp*100) + "%";
    }

    items.forEach(it => {
        ctx.fillStyle = it.type === 'L' ? "#0af" : it.type === 'S' ? "#f00" : "#ff0";
        ctx.beginPath(); ctx.arc(it.x, it.y, 11, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "#000"; ctx.font = "bold 14px Arial"; ctx.textAlign = "center";
        ctx.fillText(it.type, it.x, it.y + 5);
    });

    ctx.fillStyle = (paddleWidth > 60) ? "#0ff" : (paddleWidth < 60) ? "#f55" : "#0f0";
    ctx.fillRect(paddleX, 478, paddleWidth, 12);
    if (paddleSizeTimer > 0) {
        ctx.fillStyle = "rgba(255,255,255,0.4)";
        // ゲージ表示もdtに合わせて調整
        ctx.fillRect(paddleX, 492, paddleWidth * (paddleSizeTimer/10), 3);
    }

    ctx.fillStyle = "#fff";
    balls.forEach(b => { if(b.active) { ctx.beginPath(); ctx.arc(b.x, b.y, 7, 0, Math.PI*2); ctx.fill(); } });

    if(combo > 1) {
        ctx.fillStyle = "#ff0"; ctx.font = "bold 30px Arial"; ctx.textAlign="right";
        ctx.fillText(Math.floor(combo*1) + " COMBO!", 380, 100);
    }
    ctx.restore();
}

function showIntermission() {
    gameState = "PAUSE";
    document.getElementById("intermission-screen").style.display = "flex";
    document.getElementById("inter-score").innerText = score;
    document.getElementById("inter-time").innerText = formatTime(timeLeft);
    const storedBestScore = parseInt(localStorage.getItem('bestScore') || 0);
    if (score > storedBestScore) document.getElementById("inter-record-notice").style.display = "block";
}

function continueGame() {
    document.getElementById("intermission-screen").style.display = "none";
    document.getElementById("inter-record-notice").style.display = "none";
    initStage(stage + 1);
    gameState = "PLAY";
    lastTime = performance.now(); // タイマー再開
}

function endGame(win) {
    gameState = "RESULT"; clearInterval(gameInterval);
    let isNewRecord = false;
    const storedBestScore = parseInt(localStorage.getItem('bestScore') || 0);
    if (score > storedBestScore) { localStorage.setItem('bestScore', score); isNewRecord = true; }
    if (win && stage === 3) {
        const storedBestTime = parseInt(localStorage.getItem('bestTime') || 0);
        if (timeLeft > storedBestTime) { localStorage.setItem('bestTime', timeLeft); isNewRecord = true; }
    }
    document.getElementById("result-screen").style.display = "flex";
    document.getElementById("result-msg").innerText = win ? "ALL STAGES CLEAR!" : "GAME OVER";
    document.getElementById("final-score-display").innerText = score;
    document.getElementById("record-notice").style.display = isNewRecord ? "block" : "none";
    updateRecordsDisplay();
}

updateRecordsDisplay();
</script>
</body>
</html>