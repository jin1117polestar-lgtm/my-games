<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>BLOCK BREAKER TRILOGY</title>
    <style>
        body { background: #000; color: #fff; text-align: center; font-family: 'Arial', sans-serif; overflow: hidden; touch-action: none; margin: 0; }
        canvas { background: #000; display: block; margin: 0 auto; border: 2px solid #333; max-width: 100vw; max-height: 75vh; }
        .ui-top { height: 40px; display: flex; justify-content: space-around; align-items: center; background: #111; font-size: 14px; color: #0f0; }
        #screen { position: relative; }
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 10; }
        button { padding: 15px 30px; font-size: 18px; background: #28a745; color: white; border: none; border-radius: 8px; cursor: pointer; margin: 10px; }
        .boss-hp-bar { width: 80%; height: 10px; background: #333; border: 1px solid #fff; margin: 5px auto; display: none; }
        #boss-hp-fill { width: 100%; height: 100%; background: #f00; transition: width 0.2s; }
        .stats { font-size: 12px; color: #aaa; margin-bottom: 20px; }
    </style>
</head>
<body>

<div id="screen">
    <div class="ui-top">
        <div>STAGE: <span id="stage-num">1</span></div>
        <div>SCORE: <span id="score">0</span></div>
        <div>TIME: <span id="timer">300</span></div>
    </div>
    
    <div id="boss-ui" class="boss-hp-bar"><div id="boss-hp-fill"></div></div>

    <canvas id="gameCanvas" width="400" height="500"></canvas>

    <div id="start-screen" class="overlay">
        <h1>BLOCK BREAKER</h1>
        <div class="stats">
            BEST SCORE: <span id="best-score">0</span><br>
            BEST TIME: <span id="best-time">--:--</span>
        </div>
        <button onclick="startGame()">GAME START</button>
    </div>

    <div id="result-screen" class="overlay" style="display:none">
        <h2 id="result-msg">GAME OVER</h2>
        <div id="final-stats"></div>
        <button onclick="location.reload()">TITLE</button>
    </div>
</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// --- ゲーム変数 ---
let stage = 1;
let score = 0;
let totalTimeElapsed = 0;
let timeLeft = 300;
let isGameOver = true;
let combo = 0;
let comboTimer = 0;
let shakeTime = 0;

// ボール・パドル
let balls = [];
let paddleX = 170;
let paddleWidth = 60;
const paddleHeight = 12;
const baseBallSpeed = 3.5;
let currentBallSpeed = baseBallSpeed;

// ブロック・アイテム・ボス
let bricks = [];
let items = [];
let boss = null;
let wallBricks = []; // ステージ2の壊せない壁
let advanceY = 0; // ステージ3の迫ってくる距離

// --- セーブ機能 ---
function updateRecords() {
    const bestScore = localStorage.getItem('bestScore') || 0;
    const bestTime = localStorage.getItem('bestTime') || 9999;
    document.getElementById('best-score').innerText = bestScore;
    if(bestTime < 9999) {
        document.getElementById('best-time').innerText = formatTime(bestTime);
    }
}

function formatTime(sec) {
    let m = Math.floor(sec / 60);
    let s = sec % 60;
    return `${m}:${s < 10 ? '0' : ''}${s}`;
}

// --- 初期化 ---
function initStage(n) {
    stage = n;
    document.getElementById("stage-num").innerText = n;
    bricks = [];
    items = [];
    wallBricks = [];
    boss = null;
    advanceY = 0;
    currentBallSpeed = baseBallSpeed + (n * 0.5);
    balls = [{ x: 200, y: 400, dx: currentBallSpeed, dy: -currentBallSpeed, active: true }];
    document.getElementById("boss-ui").style.display = n === 3 ? "block" : "none";

    if (n === 1) {
        createBricks(5, 7, false);
    } else if (n === 2) {
        createBricks(6, 8, true);
        // ステージ2: 中段に壊せない壁
        for(let i=0; i<5; i++) wallBricks.push({x: i*80 + 20, y: 250, w: 40, h: 10});
    } else if (n === 3) {
        createBricks(4, 8, false);
        boss = { x: 150, y: 50, w: 100, h: 40, hp: 50, maxHp: 50 };
    }
}

function createBricks(rows, cols, hasHard) {
    for(let c=0; c<cols; c++) {
        bricks[c] = [];
        for(let r=0; r<rows; r++) {
            let hp = (hasHard && Math.random() < 0.2) ? 2 : 1;
            bricks[c][r] = { x:0, y:0, status: hp, row: r };
        }
    }
}

// --- 操作系 (相対移動) ---
let lastTouchX = null;
canvas.addEventListener("touchstart", e => { lastTouchX = e.touches[0].clientX; });
canvas.addEventListener("touchmove", e => {
    if (lastTouchX === null) return;
    let deltaX = e.touches[0].clientX - lastTouchX;
    paddleX += deltaX * 1.5; // 感度調整
    if(paddleX < 0) paddleX = 0;
    if(paddleX > canvas.width - paddleWidth) paddleX = canvas.width - paddleWidth;
    lastTouchX = e.touches[0].clientX;
    e.preventDefault();
}, {passive: false});
canvas.addEventListener("touchend", () => { lastTouchX = null; });

// --- ゲームループ ---
function startGame() {
    document.getElementById("start-screen").style.display = "none";
    isGameOver = false;
    score = 0;
    timeLeft = 300;
    initStage(1);
    requestAnimationFrame(update);
}

function update() {
    if(isGameOver) return;
    
    // タイマー・コンボ処理
    if(comboTimer > 0) comboTimer--; else combo = 0;
    
    // ステージ3の迫ってくる処理
    if(stage === 3) {
        advanceY += 0.05; 
        if(advanceY > 200) endGame(false); // 迫りすぎたら負け
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 画面揺らし
    if(shakeTime > 0) {
        ctx.save();
        ctx.translate(Math.random()*4-2, Math.random()*4-2);
        shakeTime--;
    }

    drawBricks();
    drawWall();
    drawBoss();
    drawItems();
    drawPaddle();
    drawBalls();
    drawCombo();

    if(shakeTime > 0) ctx.restore();

    checkCollisions();
    
    requestAnimationFrame(update);
}

function drawBricks() {
    let bw = 42, bh = 15, pad = 5, offT = 50 + advanceY, offL = 30;
    bricks.forEach((col, c) => {
        col.forEach((b, r) => {
            if(b.status > 0) {
                b.x = c*(bw+pad)+offL; b.y = r*(bh+pad)+offT;
                ctx.fillStyle = b.status === 2 ? "#888" : `hsl(${r*40}, 70%, 50%)`;
                ctx.fillRect(b.x, b.y, bw, bh);
            }
        });
    });
}

function drawWall() {
    ctx.fillStyle = "#555";
    wallBricks.forEach(w => ctx.fillRect(w.x, w.y, w.w, w.h));
}

function drawBoss() {
    if(!boss) return;
    ctx.fillStyle = "#f0f";
    ctx.fillRect(boss.x, boss.y + advanceY/2, boss.w, boss.h);
    document.getElementById("boss-hp-fill").style.width = (boss.hp/boss.maxHp*100) + "%";
}

function drawItems() {
    items.forEach((it, i) => {
        it.y += 2;
        ctx.fillStyle = it.type === 'wide' ? "#0af" : it.type === 'short' ? "#f00" : "#ff0";
        ctx.beginPath(); ctx.arc(it.x, it.y, 8, 0, Math.PI*2); ctx.fill();
        if(it.y > canvas.height) items.splice(i,1);
        // 取得判定
        if(it.y > canvas.height-paddleHeight-10 && it.x > paddleX && it.x < paddleX+paddleWidth) {
            applyItem(it.type);
            items.splice(i,1);
        }
    });
}

function applyItem(type) {
    if(type === 'wide') paddleWidth = Math.min(150, paddleWidth + 20);
    if(type === 'short') paddleWidth = Math.max(30, paddleWidth - 15);
    if(type === 'multi') {
        let b = balls.find(b => b.active);
        if(b) balls.push({x: b.x, y: b.y, dx: -b.dx, dy: b.dy, active: true});
    }
}

function drawPaddle() {
    ctx.fillStyle = "#0f0";
    ctx.fillRect(paddleX, canvas.height - paddleHeight - 5, paddleWidth, paddleHeight);
}

function drawBalls() {
    balls.forEach(b => {
        if(!b.active) return;
        ctx.beginPath(); ctx.arc(b.x, b.y, 6, 0, Math.PI*2); ctx.fillStyle = "#fff"; ctx.fill();
        b.x += b.dx; b.y += b.dy;
        // 壁反射
        if(b.x<6 || b.x>canvas.width-6) b.dx *= -1;
        if(b.y<6) b.dy *= -1;
        // パドル反射
        if(b.y > canvas.height-paddleHeight-15 && b.x > paddleX && b.x < paddleX+paddleWidth) {
            b.dy = -Math.abs(b.dy);
            b.dx = (b.x - (paddleX + paddleWidth/2)) * 0.2;
            combo = 0; // パドルに当たるとコンボリセット
        }
        // 落下
        if(b.y > canvas.height) {
            b.active = false;
            if(balls.filter(a=>a.active).length === 0) endGame(false);
        }
    });
}

function checkCollisions() {
    balls.forEach(ball => {
        if(!ball.active) return;
        // ブロック判定
        bricks.forEach(col => col.forEach(b => {
            if(b.status > 0 && ball.x > b.x && ball.x < b.x+42 && ball.y > b.y && ball.y < b.y+15) {
                ball.dy *= -1; b.status--;
                if(b.status === 0) {
                    combo++; comboTimer = 60;
                    score += (6 - b.row) * combo;
                    if(Math.random() < 0.08) {
                        let r = Math.random();
                        let type = r < 0.4 ? 'multi' : r < 0.7 ? 'wide' : 'short';
                        items.push({x: b.x+21, y: b.y, type: type});
                    }
                    // 加速
                    ball.dx *= 1.01; ball.dy *= 1.01;
                }
            }
        }));
        // ステージ2壁判定
        wallBricks.forEach(w => {
            if(ball.x > w.x && ball.x < w.x+w.w && ball.y > w.y && ball.y < w.y+w.h) ball.dy *= -1;
        });
        // ボス判定
        if(boss && ball.x > boss.x && ball.x < boss.x+boss.w && ball.y > boss.y+advanceY/2 && ball.y < boss.y+boss.h+advanceY/2) {
            ball.dy *= -1; boss.hp--; shakeTime = 10;
            score += 10;
            if(boss.hp <= 0) endGame(true);
        }
    });

    // クリア判定
    if(!boss && bricks.flat().every(b => b.status === 0)) {
        if(stage < 3) initStage(stage + 1);
        else endGame(true);
    }
}

function drawCombo() {
    if(combo > 1) {
        ctx.fillStyle = "#ff0"; ctx.font = "20px Bold Arial";
        ctx.fillText(combo + " COMBO!", canvas.width - 80, 80);
    }
}

function endGame(win) {
    isGameOver = true;
    clearInterval(gameTimer);
    document.getElementById("result-screen").style.display = "flex";
    document.getElementById("result-msg").innerText = win ? "MISSION COMPLETE!" : "GAME OVER";
    
    let timeSpent = 300 - timeLeft;
    totalTimeElapsed = timeSpent;
    
    if(win) {
        const bestS = localStorage.getItem('bestScore') || 0;
        const bestT = localStorage.getItem('bestTime') || 9999;
        if(score > bestS) localStorage.setItem('bestScore', score);
        if(timeSpent < bestT) localStorage.setItem('bestTime', timeSpent);
    }
    
    document.getElementById("final-stats").innerHTML = `SCORE: ${score}<br>TIME: ${formatTime(timeSpent)}`;
}

setInterval(() => {
    if(!isGameOver) {
        timeLeft--;
        document.getElementById("timer").innerText = timeLeft;
        if(timeLeft <= 0) endGame(false);
    }
}, 1000);

updateRecords();
</script>
</body>
</html>